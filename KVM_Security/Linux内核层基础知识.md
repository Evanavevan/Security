# Linux内核层基础知识

## 概述

内核是硬件与软件之间的一个中间层，是一个资源管理程序。负责将可用的共享资源(`CPU`时间、磁盘空间、网络连接等)分配得到各个系统进程。

作用是将应用层的请求传递给硬件，并充当底层驱动程序，对系统中的各种设备和组件进行寻址。

目前支持模块的是动态装卸(裁剪)，`Linux`内核就是基于这个策略实现的。`Linux`进程采用的是层次结构，每个进程都依赖于一个父进程。内核启动`init`程序作为第一个进程，该进程负责进一步的系统初始化操作。`init`进程是进程树的根，所有的进程都直接或者间接起源于该进程。

## 源代码目录结构

`Linux`内核源代码包括三个主要部分：

- 内核核心代码，包括内存管理、文件管理、设备驱动程序，以及其它的支撑子系统，例如电源管理、`Linux`初始化等

- 其它非核心代码，例如库文件（因为`Linux`内核是一个自包含的内核，即内核不依赖其它的任何软件，自己就可以编译通过）、固件集合、`KVM`（虚拟机技术）等

- 编译脚本、配置文件、帮助文档、版权说明等辅助性文件

|                        根目录                         |    子目录     |                           功能描述                           |
| :---------------------------------------------------: | :-----------: | :----------------------------------------------------------: |
|                      `include/`                       |       -       |    内核头文件，需要提供给外部模块（例如用户空间代码）使用    |
|                       `kernel/`                       |       -       | Linux内核的核心代码，包含了内存管理、文件管理、设备驱动程序，以及和进程调度相关的模块 |
|                         `mm/`                         |       -       |                        内存管理子系统                        |
|                         `fs/`                         |       -       |                         `VFS`子系统                          |
|                        `net/`                         |       -       |                不包括网络设备驱动的网络子系统                |
|                        `ipc/`                         |       -       |                  `IPC`（进程间通信）子系统                   |
|                        `arch/`                        |       -       |           体系结构相关的代码，例如`arm`, `x86`等等           |
|                        `arch/`                        |    `mach`     |               具体的`machine/board`相关的代码                |
|                        `arch/`                        | `include/asm` |                     体系结构相关的头文件                     |
|                        `arch/`                        |  `boot/dts`   |                 设备树（`Device Tree`）文件                  |
|                        `init/`                        |       -       |               `Linux`系统启动初始化相关的代码                |
|                       `block/`                        |       -       |                       提供块设备的层次                       |
|                       `sound/`                        |       -       |         音频相关的驱动及子系统，可以看作“音频子系统”         |
|                      `drivers/`                       |       -       | 设备驱动（在`Linux kernel 3.10`中，设备驱动占了`49.4%`的代码量） |
|                        `lib/`                         |       -       | 实现需要在内核中使用的库函数，例如`CRC`、`FIFO`、`list`、`MD5`等 |
|                       `crypto/`                       |       -       |                    加密、解密相关的库函数                    |
|                      `security/`                      |       -       |                  提供安全特性（`SELinux`）                   |
|                        `virt/`                        |       -       |               提供虚拟机技术（`KVM`等）的支持                |
|                        `usr/`                         |       -       |                  用于生成`initramfs`的代码                   |
|                      `firmware/`                      |       -       |                 保存用于驱动第三方设备的固件                 |
|                      `samples/`                       |       -       |                         一些示例代码                         |
|                       `tools/`                        |       -       |              一些常用工具，如性能剖析、自测试等              |
| `Kconfig`<br/>`Kbuild`<br/>`Makefile`<br/> `scripts/` |       -       |                用于内核编译的配置文件、脚本等                |
|                       `COPYING`                       |       -       |                           版权声明                           |
|                     `MAINTAINERS`                     |       -       |                          维护者名单                          |
|                       `CREDITS`                       |       -       |                   `Linux`主要的贡献者名单                    |
|                   `REPORTING-BUGS`                    |               |                        Bug上报的指南                         |
|             `Documentation`<br/> `README`             |       -       |                        帮助、说明文档                        |

## `Linux`内核体系结构简析

### `Linux`系统层次结构

![Linux系统层次结构](http://www.openpcba.com/upload/cat_upload/20191104/eb644ed97882812c4dd4b567d83c8007.jpeg)

最上面是用户（或应用程序）空间，这是用户应用程序执行的地方。用户空间之下是内核空间，`Linux `内核正是位于这里，当然`glibc`（`GNU C Library `）也在这里，它提供了连接内核的系统调用接口，还提供了在用户空间应用程序和内核之间进行转换的机制。这点非常重要，因为内核和用户空间的应用程序使用的是不同的保护地址空间，每个用户空间的进程都使用自己的虚拟地址空间，而内核则占用单独的地址空间。

`Linux `内核可以进一步划分成 `3` 层。最上面是系统调用接口，它实现了一些基本的功能，例如 `read `和 `write`。系统调用接口之下是内核代码，可以更精确地定义为独立于体系结构的内核代码，这些代码是` Linux `所支持的所有处理器体系结构所通用的。在这些代码之下是依赖于体系结构的代码，构成了通常称为 `BSP`（`Board Support Package`）的部分。这些代码用作给定体系结构的处理器和特定的平台。

`Linux `内核实现了很多重要的体系结构属性，在或高或低的层次上，内核被划分为多个子系统。`Linux` 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中，这与微内核的体系结构（所有其他的功能都委托给一些独立进程，这些进程通过明确定义的通信接口与中心内核通信）不同，后者会提供一些基本的服务，例如通信、`I/O`、内存和进程管理，更具体的服务都是插入到微内核层中的。 

随着时间的流逝，`Linux` 内核在内存和 `CPU `使用方面具有较高的效率，并且非常稳定。但是对于 `Linux` 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。`Linux` 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 `Linux` 可以在一个具有内存管理单元（`Memory Manage Unit, MMU`）的处理器上运行，也可以在那些不提供` MMU` 的处理器上运行。

`Linux `内核的 `uClinux` 移植提供了对非 `MMU` 的支持。

### `Linux`内核体系结构

![Linux内核体系结构](http://www.openpcba.com/upload/cat_upload/20191104/12ecea9646ba65509ec8e67db8aeda0c.jpeg)

`Linux`内核的主要组件有：系统调用接口、进程管理、内存管理、虚拟文件系统、网络堆栈、设备驱动程序、硬件架构的相关代码。

#### 系统调用接口

`SCI `层提供了某些机制执行从用户空间到内核的函数调用，正如前面讨论的一样，这个接口依赖于体系结构，甚至在相同的处理器家族内也是如此。`SCI` 实际上是一个非常有用的函数，功能是调用多路复用和多路分解服务。在`./linux/kernel` 中可以找到 `SCI` 的实现，并在 `./linux/arch` 中找到依赖于体系结构的部分。

#### 进程管理（进程调度）

进程管理的重点是进程的执行。在内核中，这些进程称为线程，代表了单独的处理器虚拟化（线程代码、数据、堆栈和 `CPU` 寄存器）。在用户空间，通常使用进程这个术语，不过 `Linux` 实现并没有区分这两个概念（进程和线程）。内核通过 `SCI` 提供了一个应用程序编程接口（`API`）来创建一个新进程（`fork`、`exec` 或 `POSIX [Portable Operating System Interface]` 函数），停止进程（`kill`、`exit`），并在它们之间进行通信和同步（`signal` 或者 `POSIX` 机制）。

进程管理还包括处理活动进程之间共享 `CPU` 的需求。内核实现了一种新型的调度算法，不管有多少个线程在竞争 `CPU`，这种算法都可以在固定时间内进行操作。这种算法就称为 `O(1)` 调度程序，这个名字就表示它调度多个线程所使用的时间和调度一个线程所使用的时间是相同的。`O(1)`调度程序也可以支持多处理器（称为对称多处理器或 `SMP`）。在 `./linux/kernel` 中找到进程管理的源代码，在 `./linux/arch` 中可以找到依赖于体系结构的源代码。

![进程调度子系统](http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201402/919f3e6af8ddc24ecdebc6b27905c35c20140221042338.gif)

- `Scheduling Policy`，实现进程调度的策略，它决定哪个（或哪几个）进程将拥有`CPU`。

- `Architecture-specific Schedulers`，体系结构相关的部分，用于将对不同`CPU`的控制，抽象为统一的接口。这些控制主要在`suspend`和`resume`进程时使用，牵涉到`CPU`的寄存器访问、汇编指令操作等。

- `Architecture-independent Scheduler`，体系结构无关的部分。它会和`Scheduling Policy模块`沟通，决定接下来要执行哪个进程，然后通过`Architecture-specific Schedulers`模块`resume`指定的进程。
- `System Call Interface`，系统调用接口。进程调度子系统通过系统调用接口，将需要提供给用户空间的接口开放出去，同时屏蔽掉不需要用户空间程序关心的细节。

#### 内存管理

内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的内存页方式进行管理的（对于大部分体系结构来说都是 `4KB`）。`Linux` 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 `4KB` 缓冲区，`Linux` 提供了对 `4KB` 缓冲区的抽象，例如 `slab` 分配器。这种内存管理模式使用 `4KB` 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空，这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。因此，页面可以移出内存并放入磁盘中，这个过程称为交换，因为页面会从内存交换到硬盘上。内存管理的源代码可以在 `./linux/mm` 中找到。

![内存管理子系统](http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201402/fec4f86580c63a2bbd3fae7140fd840220140221042341.gif)

- `Architecture Specific Managers`，体系结构相关部分。提供用于访问硬件`Memory`的虚拟接口。
- `Architecture Independent Manager`，体系结构无关部分。提供所有的内存管理机制，包括：以进程为单位的`memory mapping`；虚拟内存的`Swapping`。
- `System Call Interface`，系统调用接口。通过该接口，向用户空间程序应用程序提供内存的分配、释放，文件的`map`等功能。

#### 虚拟文件系统

虚拟文件系统（`VFS`）是 `Linux` 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。`VFS` 在 `SCI` 和内核所支持的文件系统之间提供了一个交换层。

![虚拟文件系统架构](http://www.openpcba.com/upload/cat_upload/20191104/06f44c21625f25063999b9377791c6b2.jpeg)

在 `VFS` 上面，是对诸如 `open`、`close`、`read` 和 `write` 之类函数的一个通用 `API` 抽象。在 `VFS` 下面是文件系统抽象，它定义了上层函数的实现方式，它们是给定文件系统（超过 `50` 个）的插件。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关），这个缓存层通过将数据保留一段时间的方式（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。文件系统的源代码可以在 `./linux/fs` 中找到。

![VFS子系统](http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201402/383e358076ad52cf798f8595d324ec8220140221042343.gif)

- `Device Drivers`，设备驱动，用于控制所有的外部设备及控制器。由于存在大量不能相互兼容的硬件设备（特别是嵌入式产品），所以也有非常多的设备驱动。因此，`Linux`内核中将近一半的`Source Code`都是设备驱动，大多数的`Linux`底层工程师（特别是国内的企业）都是在编写或者维护设备驱动，而无暇估计其它内容（它们恰恰是`Linux`内核的精髓所在）。
- `Device Independent Interface`， 该模块定义了描述硬件设备的统一方式（统一设备模型），所有的设备驱动都遵守这个定义，可以降低开发的难度。同时可以用一致的形势向上提供接口。
- `Logical Systems`，每一种文件系统，都会对应一个`Logical System`（逻辑文件系统），它会实现具体的文件系统逻辑。
- `System Independent Interface`，该模块负责以统一的接口（快设备和字符设备）表示硬件设备和逻辑文件系统，这样上层软件就不再关心具体的硬件形态了。
- `System Call Interface`，系统调用接口，向用户空间提供访问文件系统和硬件设备的统一的接口。

#### 网络堆栈

网络堆栈在设计上遵循模拟协议本身的分层体系结构。回想一下，` IP (Internet Protocol)` 是传输协议（通常称为传输控制协议或 `TCP`）下面的核心网络层协议。`TCP` 上面是 `socket` 层，它是通过 `SCI` 进行调用的。`socket` 层是网络子系统的标准 `API`，它为各种网络协议提供了一个用户接口。从原始帧访问到 `IP` 协议数据单元（`PDU`），再到 `TCP` 和 `UDP (User Datagram Protocol)`，`socket` 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 `./linux/net`中找到。

![网络子系统](http://www-x-wowotech-x-net.img.abc188.com/content/uploadfile/201402/d10ebccc68cd8ee0030cf7770442247520140221042346.gif)

- `Network Device Drivers`，网络设备的驱动，和`VFS`子系统中的设备驱动是一样的。
- `Device Independent Interface`，和`VFS`子系统中的是一样
- `Network Protocols`，实现各种网络传输协议，例如`IP`, `TCP`, `UDP`等等。
- `Protocol Independent Interface`，屏蔽不同的硬件设备和网络协议，以相同的格式提供接口（`socket`)。
- `System Call interface`，系统调用接口，向用户空间提供访问网络设备的统一的接口。

#### 设备驱动程序

`Linux` 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。`Linux` 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 `Bluetooth`、`I2C`、`serial` 等。设备驱动程序的代码可以在 `./linux/drivers` 中找到。

#### 依赖体系结构的代码

尽管 `Linux` 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。`./linux/arch` 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了` BSP`）。对于一个典型的桌面系统来说，使用的是 `x86` 目录，每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 `./linux/arch` 中找到。



如果 `Linux` 内核的可移植性和效率还不够好，`Linux` 还提供了其他一些特性，它们无法划分到上面的分类中。作为一个生产操作系统和开源软件，`Linux` 是测试新协议及其增强的良好平台。`Linux` 支持大量网络协议，包括典型的 `TCP/IP`，以及高速网络的扩展（大于 `1 GbE[Gigabit Ethernet] 和 10 GbE`）。`Linux` 也可以支持诸如流控制传输协议（`SCTP`）之类的协议，它提供了很多比 `TCP` 更高级的特性（是传输层协议的接替者）。

`Linux` 还是一个动态内核，支持动态添加或删除软件组件，被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。

`Linux `最新的一个增强是可以用作其他操作系统的操作系统（称为系统管理程序）。最近，对内核进行了修改，称为基于内核的虚拟机（`KVM`），这个修改为用户空间启用了一个新的接口，它可以允许其他操作系统在启用了 `KVM` 的内核之上运行。除了运行 `Linux` 的其他实例之外， `Microsoft Windows`也可以进行虚拟化，惟一的限制是底层处理器必须支持新的虚拟化指令。



